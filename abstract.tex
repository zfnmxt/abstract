%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ENGLISH VERSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{center}
\textbf{Abstract}
\end{center}
In this thesis, I describe two things I did:
\begin{enumerate*}[label=\arabic*)]
\item a compiler transformation that
implements performant automatic differentiation (AD) for a functional,
data-parallel language and
\item an approach for rank polymorphism in a statically typed language with
  parametric polymorphism and type inference.
\end{enumerate*}

On the AD side of things, a method for efficient reverse mode AD on nested
parallel programs is presented. The approach uses a re-computation-based approach
that eliminates storing program variables for the reverse sweep; instead,
variables are recomputed as needed in each new scope. Under this technique,
perfectly nested scopes do not introduce re-computation. This is exploited by
applying a repertoire of compiler transformations to transform code into perfect
nests.
%
The language uses a lexicon of high-level parallel combinators---such as
\texttt{map}, \texttt{reduce}, and \texttt{scan}---to build
parallel-by-construction programs. Rewrite rules to differentiate each
combinator are derived, yielding nested-parallel code which itself consists of
parallel combinators. The resulting parallel code is aggressively optimized
using a suite of general and AD-specific optimizations.
%
An implementation in the Futhark programming language is reported on and
evaluated against existing other modern AD implementations on a suite of
benchmarks, demonstrating competitive performance.

On the rank polymorphism side of things, a mechanism for automatically lifting
functions and replicating function arguments in a static context is
presented. The aim is to capture the programming experience in dynamically typed
array languages like NumPy and APL, which permit rank-polymorphic applications,
while also preserving static typing guarantees. The type system---which supports
parametric polymorphism, higher-order functions, and top-level
let-generalization---determines the minimum number of lifting and replication
operations by generating (and solving) integer linear programs from constraints
generated at function application sites. Key theoretical properties of the
mechanism are given. An implementation of the mechanism within the Futhark
compiler is described and demonstrates the system's practicality.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DANISH VERSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\textbf{Resum\'e}
\end{center}
Foreliggende afhandling redegør for mine to bedrifter:
\begin{enumerate*}[label=\arabic*)]
\item udførsel af en automatisk programbearbejdning, der kan udføre
  automatisk differentiering (AD) af programmer skrevet i et
  funktionsorienteret og dataparallelt programmeringssprog, samt
\item en tilgang til rangpolymorfi i et programmeringssprog med
  statiske typer, parametrisk polymorfi, og typeinferens.
\end{enumerate*}

For så vidt vedrører AD, da præsenterer jeg en effektiv fremgangsmåde
for den såkaldte bagvendte tilgang. Denne fremgangsmåde undgår den
sædvanlige lagring af de mellemresultater der skal bruges til
returgennemløbet, og genberegner i stedet de nødvendige resultater for
hvert indlejringstrin i programmet. Som et særtilfælde kræver perfekt
indlejrede løkker ikke genberegning; en egenskab der udnyttes ved at
foretage automatisk omskrivning af programtekst til slig perfekt
indlejrede løkker.
%
Det sprog, hvorpå jeg udfører automatisk differentiering, udtrykker
deterministisk parallelisme via kombinatorer såsom \texttt{map},
\texttt{reduce}, og \texttt{scan}. Differentieringsreglerne for hver
af disse kombinatorer gives, som ligeledes er udtrykt via tilsvarende
parallelle kombinatorer. Den herfra dannede parallelle programtekst
optimeres derefter gennem en række almene og specialiserede
programoptimeringsteknikker.
%
En konkret udførsel af fremgangsmåden er foretaget på oversætteren for
programmeringssproget Futhark, og via en eksperimentel sammenligning
af køretidsresultater med andre værktøjer til AD, demonstreres en
konkurrencedygtig præstation.

For så vidt vedrører rangpolymorfi, da redegør jeg for en
fremgangsmåde til automatisk tilpasning af funktioner og
funktionsargumenter således at de kan anvendes på data af udvidet
rang. Hensigten med denne fremgangsmåde er at imitere
programmeringsoplevelsen i dynamisk typede geledsprog såsom NumPy og
APL, der tillader rankpolymorfe funktionsanvendelser, men også
samtidigt at bevare ønskværdige typesystemsgarantier. Typesystemet
understøtter parametrisk polymorfi, højereordensfunktioner, samt
let-generalisering, og er derudover i stand til at afgøre den minimale
udvidelse af funktioner til argumenter af højere rang, ved at løse
lineære heltalsproblemer dannet ud fra de typeligninger der opstår ved
funktionsanvendelsespunkter. Centrale teoretiske egenskaber for
systemet præsenteres. En implementering af fremgangsmåden, udført ved
en udvidelse af oversætteren for programmeringssproget Futhark, er
blevet udført, hvilket tjener til at tydeliggøre typesystemets
praktiske anvendelighed.
